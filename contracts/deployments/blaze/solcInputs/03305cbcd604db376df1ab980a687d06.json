{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@thirdweb-dev/contracts/external-deps/openzeppelin/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/apis/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\ninterface Common {\r\n    enum Stage {\r\n        JOIN, \r\n        GET, \r\n        PAYBACK, \r\n        WITHDRAW,\r\n        CANCELED,\r\n        ENDED\r\n    }\r\n\r\n    enum Status { AVAILABLE, TAKEN }\r\n\r\n    enum UnitStatus { CURRENT, RECORD }\r\n\r\n    enum Router { PERMISSIONLESS, PERMISSIONED }\r\n\r\n    struct Safe {\r\n        address id;\r\n        bytes32 ownerHash;\r\n    }\r\n\r\n    struct Pool {\r\n        address admin;\r\n        address beneficiary;\r\n        LowInt lInt;\r\n        BigInt bigInt;\r\n        Interest interest;\r\n    }\r\n\r\n    struct LowInt {\r\n        uint quorum;\r\n        // uint userCount;\r\n        uint colCoverage;\r\n        uint duration;\r\n        Status status;\r\n        Router router;\r\n        Stage stage;\r\n    }\r\n\r\n    struct BigInt {\r\n        uint unit;\r\n        uint currentPool;\r\n        uint recordId;\r\n    }\r\n\r\n    struct Point {\r\n        uint contributor;\r\n        uint creator; \r\n    }\r\n\r\n    struct Interest {\r\n        uint fullInterest;\r\n        uint intPerSec;\r\n        uint intPerChoiceOfDur;\r\n    }\r\n\r\n      /**\r\n   *  @dev Data for each pool. \r\n   *  @param isMember : Whether user is a member or not\r\n   *  @param payDate: The data in future on which the borrowed fund must be retured\r\n   *  @param turnTime : This is a period or interval between the last received and the next.\r\n   *  @param loan: Total debts owed by the last fund recipient.\r\n   *  @param colBals: Collateral balances of the last recipient.\r\n   *  @param sentQuota : Whether an user/current msg.sender has received or not.\r\n   *  @param id : Address of the last recipient.  \r\n   */\r\n  struct Contributor {\r\n    bool isMember;\r\n    uint payDate;\r\n    uint turnTime;\r\n    uint loan;\r\n    uint colBals;\r\n    address id;\r\n    bool sentQuota;\r\n  }\r\n\r\nstruct Price {\r\n    uint128 price;\r\n    uint8 decimals;\r\n  }\r\n}"
    },
    "contracts/apis/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport \"./IERC20Metadata.sol\";\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 is IERC20Metadata{\r\n    error NotCallable();\r\n    error AddressIsZero(address);\r\n    error NoPreviousLockDetected();\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    \r\n    /** \r\n     * @dev Moves `amounts` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event for each transfer.\r\n     * Note: BE AWARE OF THE GAS COST WHEN USING THIS FUNCTION. IT INCREASES \r\n                RELATIVE TO THE ACCOUNTS ARRAY\r\n     */\r\n    function batchTransfer(uint[] memory amounts, address[] memory accounts) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n\r\n    /**@dev Locks specific amount of JFT to the private ledger.\r\n        param: routeTo - Alternative address that funds will be sent to when panic call is made.\r\n        param: amount - Amount to lock.\r\n    */\r\n    function lockToken(address routeTo, uint256 amount) external returns(bool);\r\n\r\n    /**@dev Moves an 'amount' from private ledger to regular balances.\r\n        @param amount - Amount to unlock.\r\n        Note: If the lock duration was set, holder will not be able to unlock until the \r\n            set time has passed else they can withdraw to regular balance anytime.\r\n     */\r\n    function unlockToken(uint amount) external returns(bool);\r\n\r\n    /** @dev Returns seperate balances of @param who\r\n        return value will be in struct format having two values\r\n     */\r\n    function accountBalances(address who) external view returns(Balances memory);\r\n   \r\n    // /**@dev Return JFT's Metadata including the information of `who`\r\n    //  */\r\n    // function getInfo(address who) external view returns(Protected memory);\r\n\r\n    /**\r\n     * @dev PanicUnlock is meant to be invoked only by the Attorney.\r\n     * It should only be called when JFT holder has lost access to their account and they had \r\n     * earlier initiated a lock. The locked token is simply unlocked and sent to an escape address\r\n     * provided at the time the lock was activated.\r\n     * \r\n     * Note: Attorney charges a fee for doing this. \r\n     * @param account : Account that owns this token.\r\n     */\r\n    function panicUnlock(address account, Balances memory _bal) external returns(bool);\r\n\r\n    struct Protected {\r\n        uint256 value; // Total value currently locked\r\n        address escapeTo;\r\n    }\r\n\r\n    struct Balances {\r\n        uint256 spendable;\r\n        Protected locked;\r\n    }\r\n\r\n    struct TokenInfo {\r\n        uint8 decimals;\r\n        uint256 totalSupply;\r\n        string name;\r\n        string symbol;\r\n        address attorney;\r\n        // address rewarder;\r\n    }\r\n}\r\n"
    },
    "contracts/apis/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "contracts/libraries/Utils.sol": {
      "content": "  // SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { SafeMath } from \"@thirdweb-dev/contracts/external-deps/openzeppelin/utils/math/SafeMath.sol\";\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport { Common } from \"../apis/Common.sol\";\r\n\r\nlibrary Utils {\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n\r\n    error InsufficientCollateral(uint256 actual, uint256 expected);\r\n    error CollateralCoverageCannotGoBelow_100();\r\n    error InvalidDenominator(string message);\r\n\r\n    ///@dev Requires all conditions to be true \r\n    function assertTrue_2(bool a, bool b, string memory errorMessage) internal pure {\r\n        require(a && b, errorMessage);\r\n    }\r\n\r\n    ///@dev Requires single condition to be true \r\n    function assertTrue(bool condition, string memory errorMessage) internal pure {\r\n        require(condition, errorMessage);\r\n    }\r\n\r\n    ///@dev Requires conditions to be true \r\n    function assertFalse(bool condition, string memory errorMessage) internal pure {\r\n        require(!condition, errorMessage);\r\n    }\r\n\r\n    /**     @dev Calculation of percentage.\r\n        *   This is how we calculate percentage to arrive at expected value with \r\n        *   precision.\r\n        *   We choose a base value (numerator as 10000) repesenting a 100% of input value. This means if Alice wish to set \r\n        *   her interest rate to 0.05% for instance, she only need to multiply it by 100 i.e 0.05 * 100 = 5. Her input will be 5. \r\n        *   Since Solidity do not accept decimals as input, in our context, the minimum value to parse is '0' indicating \r\n        *   zero interest rate. If user wish to set interest at least, the minimum value will be 1 reprensenting 0.01%.\r\n        *   The minimum interest rate to set is 0.01% if interest must be set at least.\r\n        *   @notice To reiterate, raw interest must be multiplied by 100 before giving as input. \r\n        *   @param principal : The principal value on which the interest is based. Value should be in decimals.\r\n        *   @param interest : Interest rate. \r\n        *   \r\n        *   Rules\r\n        *   -----\r\n        *   - Principal cannot be less than base.\r\n        *   - Interest cannot be greater than (2 ^ 16) - 1\r\n    */\r\n    function _getPercentage(\r\n        uint principal, \r\n        uint16 interest\r\n    )\r\n        internal \r\n        pure \r\n        returns (uint _return) \r\n    {\r\n        uint16 base = _getBase(); \r\n        if(interest == 0 || principal == 0) return 0;\r\n        assertTrue(interest < type(uint16).max, \"Interest overflow\");\r\n        assertTrue(principal > base, \"Principal should be greater than 10000\");\r\n        _return = principal.mul(interest).div(base);\r\n    }\r\n\r\n    /**\r\n     * Percentage base\r\n     */\r\n    function _getBase() internal pure returns(uint16 base) {\r\n        base = 10000;\r\n    }\r\n    \r\n    function _decimals(address asset) internal view returns(uint8 decimals) {\r\n        decimals = IERC20Metadata(asset).decimals();\r\n    }\r\n\r\n    /**\r\n     * @dev Computes collateral on the requested loan amount\r\n     * @param ccr : Collateral ratio. Must be multiply by 100 before parsing as input i.e if raw ccr\r\n     *              is 1.2, it should be rendered as 1.2 * 100 = 120.\r\n     * @param price : Price of Collateral token base with decimals.\r\n     * @param loanReqInDecimals : Total requested contribution in USD\r\n     * @notice Based on Simplifi mvp, loans are collaterized in XFI until we add more pairs\r\n     *         in the future.\r\n     * Example: Alice, Bob and Joe formed a band to contribute $100 each where duration is for \r\n     * 10 days each. Alice being the admin set ccr to 1.5 equivalent to 150% of the total sum \r\n     * contribution of $300. If the price of XFI as at the time of GF is $0.5/XFI, where XFI decimals\r\n     * is in 18, we calculate the required XFI to stake as follows:   \r\n     *  \r\n     *                    totalContribution *  (10** XFIdecimals)   |                 raw ccr\r\n     *   totalLoanInXFI = --------------------------------------    |    actualCCR = (1.5 * 100) * 100 = 1500\r\n     *                        (xfiPriceIndecimals)                  |\r\n     * \r\n     *                     totalLoanInXFI * actualCCR\r\n     *        XFINeeded = ----------------------------\r\n     *                             _getBase()\r\n     * \r\n     *  Therefore, Alice is required to stake 900XFI to GF $300 for 10 days.\r\n     *   \r\n     */\r\n    function computeCollateral(\r\n        Common.Price memory price,\r\n        uint24 ccr,\r\n        uint loanReqInDecimals\r\n    ) \r\n        internal\r\n        pure \r\n        returns(uint256 expColInNative) \r\n    {\r\n        uint8 minCCR = 100;\r\n        if(ccr < minCCR) revert CollateralCoverageCannotGoBelow_100();\r\n        uint48 _ccr = uint48(uint(ccr).mul(100));\r\n        uint totalLoanInNative = loanReqInDecimals.mul(10**price.decimals).div(price.price);\r\n        expColInNative = totalLoanInNative.mul(_ccr).div(_getBase());\r\n    }\r\n\r\n    /**\r\n        @dev Computes maker fee.\r\n        @param makerRate : The amount of fee (in %) charged by the platform on the principal given to a borrower.\r\n            Note : Raw rate must multiply by 100 to get the expected value i.e\r\n            if maker rate is 0.1%, it should be parsed as 0.1 * 100 = 10.\r\n            See `_getPercentage()`.\r\n        @param amount should be in decimals.\r\n    */\r\n    function computeFee(\r\n        uint amount, \r\n        uint16 makerRate\r\n    ) \r\n        internal \r\n        pure \r\n        returns (uint mFee) \r\n    {\r\n        mFee = _getPercentage(amount, makerRate);\r\n    }\r\n\r\n    /**\r\n     * @dev Compute interest based on specified rate.\r\n     * @param rate : Interest rate.\r\n     * @param principal : Total expected contribution.\r\n     * \r\n     * Rules\r\n     * -----\r\n     * - Duration cannot exceed 30days i.e 2592000 seconds uint24 seconds\r\n     */\r\n    function computeInterestsBasedOnDuration(\r\n        uint principal,\r\n        uint16 rate,\r\n        uint24 fullDurationInSec\r\n    )\r\n        internal \r\n        pure \r\n        returns(Common.Interest memory _itr) \r\n    {\r\n        Common.Interest memory it;\r\n        require(fullDurationInSec <= _maxDurationInSec(), \"Utils: FullDur or DurOfChoice oerflow\");\r\n        it.fullInterest = _getPercentage(principal, rate); // Full interest for fullDurationInSec\r\n        if(it.fullInterest > 0) {\r\n            it.intPerSec = it.fullInterest.mul(1).div(fullDurationInSec);\r\n        }\r\n        _itr = it; \r\n    }\r\n\r\n    /**\r\n     * @dev Max duration : 30Days, presented in seconds\r\n     */\r\n    function _maxDurationInSec() internal pure returns(uint24 max) {\r\n        max = 2592000;\r\n    }\r\n\r\n    function notZeroAddress(address target) internal pure {\r\n        require(target != address(0), \"Zero address\");\r\n    }\r\n\r\n    function _now() internal view returns(uint64 date) {\r\n        date = uint64(block.timestamp);\r\n    }\r\n\r\n}"
    },
    "contracts/peripherals/Agent.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\"; \r\n\r\nabstract contract Agent is Ownable {\r\n    error InvalidAgentAddress();\r\n    error AgentAddressIsTheSame();\r\n\r\n    address private agent;\r\n\r\n    // Platform fee\r\n    uint public makerRate;\r\n\r\n    constructor(address controller, address newAgent) Ownable(controller){\r\n        agent = newAgent;\r\n    }\r\n\r\n    function replaceAgent(address newAgent) public onlyOwner {\r\n        if(newAgent == address(0)) revert InvalidAgentAddress();\r\n        if(newAgent == agent) revert AgentAddressIsTheSame();\r\n        agent = newAgent;\r\n    }\r\n\r\n    /**\r\n     * @dev Adjust fee\r\n     * @param newRate : New fee\r\n     */\r\n    function setFee(uint16 newRate) public onlyOwner {\r\n        makerRate = newRate;\r\n    }\r\n}"
    },
    "contracts/peripherals/Contributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"../apis/Common.sol\";\r\n\r\nabstract contract Contributor {\r\n    error OnlyContributorIsAllowed();\r\n    error OnlyNonContributorIsAllowed();\r\n\r\n    //Mapping of unit to position to contributors\r\n    mapping (uint256 => mapping(uint => Common.Contributor))public contributors;\r\n\r\n    // Mapping of unit to userCount\r\n    mapping (uint256 => uint) public userCounts;\r\n\r\n    // Mapping of user to unit to position\r\n    mapping (address => mapping(uint256 => uint)) public positions;\r\n\r\n    /**\r\n     * @dev Only contributor in a pool is allowed\r\n     * @param user : Target\r\n     * @param unit : Unit Contribution\r\n    */\r\n    function _onlyContributor(address user, uint256 unit) internal view {\r\n        if(!_getProfile(user, unit).isMember) revert OnlyContributorIsAllowed();\r\n    }\r\n\r\n    /**\r\n     * @dev Only Non contributor in a pool is allowed\r\n     * @param user : Target\r\n     * @param unit : Unit Contribution\r\n     */\r\n    function _onlyNonContributor(address user, uint256 unit) internal view {\r\n        if(_getProfile(user, unit).isMember) revert OnlyNonContributorIsAllowed();\r\n    }\r\n\r\n    /**\r\n     * @dev returns user's profile status in a pool\r\n     * @param user : Target address\r\n     * @param unit : Unit contribution\r\n     */\r\n    function _getProfile(address user, uint256 unit) internal view returns(Common.Contributor memory _isMember) {\r\n        uint pos = positions[user][unit];\r\n        _isMember = contributors[unit][pos];\r\n    }\r\n\r\n    /**\r\n     * @dev returns user's profile status in a pool\r\n     * @param unit : Unit contribution\r\n     */\r\n    function _getExpected(uint256 unit) internal view returns(Common.Contributor memory _isMember) {\r\n        uint pos = userCounts[unit];\r\n        _isMember = contributors[unit][pos];\r\n    }\r\n\r\n    /**\r\n     * @dev returns user's profile status in a pool\r\n     * @param user : Target address\r\n     * @param unit : Unit contribution\r\n     * @param date : Date/timestamp\r\n     */ \r\n    function _setTurnTime(address user, uint256 unit, uint64 date) internal {\r\n        uint pos;\r\n        if(user == address(0)){\r\n            pos = userCounts[unit];\r\n        } else {\r\n            pos = positions[user][unit];\r\n        }\r\n        contributors[unit][pos].turnTime = date;\r\n    }\r\n\r\n    /**\r\n     * @dev returns user's contributorship status in a pool\r\n     * @param newProfile : Target profile\r\n     * @param unit : Unit contribution\r\n     */\r\n    function _addContributor(uint256 unit, Common.Contributor memory newProfile) internal {\r\n        uint pos = userCounts[unit];\r\n        userCounts[unit] = pos + 1;\r\n        contributors[unit][pos] = newProfile;\r\n        positions[newProfile.id][unit] = pos;\r\n    }\r\n\r\n    function _incrementUserCount(uint256 unit) internal {\r\n        userCounts[unit] += 1;\r\n    }\r\n\r\n    /**\r\n     * @dev returns user's contributorship status in a pool\r\n     * @param user : Target address\r\n     * @param unit : Unit contribution\r\n     */\r\n    function _removeContributor(address user, uint256 unit) internal {\r\n        uint pos = positions[user][unit];\r\n        delete contributors[unit][pos];\r\n        delete positions[user][unit];\r\n    }\r\n\r\n    function _getUserCount(uint256 unit) internal view returns(uint _count) {\r\n        _count = userCounts[unit];\r\n    }\r\n\r\n    function _resetUserCount(uint256 unit) internal {\r\n        userCounts[unit] = 0;\r\n    }\r\n\r\n    function _swapFullProfile(\r\n        uint256 unit,\r\n        address actCaller,\r\n        Common.Contributor memory expcData\r\n    )\r\n        internal\r\n        returns(Common.Contributor memory aCData) \r\n    {\r\n        uint aSlot = positions[actCaller][unit];\r\n        uint eSlot = positions[expcData.id][unit];\r\n        aCData = contributors[unit][aSlot];\r\n        aCData.turnTime = expcData.turnTime;\r\n        expcData.turnTime = 0;\r\n        contributors[unit][eSlot] = aCData;\r\n        contributors[unit][aSlot] = expcData;\r\n        positions[actCaller][unit] = eSlot;\r\n        positions[expcData.id][unit] = aSlot;\r\n        contributors[unit][aSlot].turnTime = expcData.turnTime;\r\n    }\r\n}"
    },
    "contracts/peripherals/CreatePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport { Agent } from \"./Agent.sol\";\r\nimport { Pools } from \"./Pools.sol\";\r\nimport { Safe } from \"./Safe.sol\";\r\nimport { Contributor } from \"./Contributor.sol\";\r\nimport { Common } from \"../apis/Common.sol\";\r\nimport { IERC20 } from \"../apis/IERC20.sol\";\r\nimport { TokenInUse } from \"./TokenInUse.sol\";\r\nimport { Point } from \"./Point.sol\";\r\nimport { Utils } from \"../libraries/Utils.sol\";\r\n\r\ncontract CreatePool is Agent, Pools, Safe, Point, TokenInUse, Contributor {\r\n    // using SafeMath for uint256;\r\n    using Utils for *;\r\n\r\n    error InvalidSafe();\r\n    error PoolIsTaken();\r\n    error AddressMustBeArrayOfOneAddress();\r\n    error CollaterlCoverageTooLow();\r\n    error DurationExceed720HoursOrIsZero();\r\n    error UserArrayExceedOne();\r\n    error AddingUserEnded();\r\n    error TokenBalanceInSafeNotTally();\r\n\r\n    constructor(\r\n        address controller, \r\n        address newAgent, \r\n        IERC20 _token\r\n    ) \r\n        Agent(controller, newAgent) TokenInUse(_token)\r\n    {}\r\n\r\n    function _createPool(\r\n        address newSafe, \r\n        address[] memory users, \r\n        uint256 unit,\r\n        uint8 quorum,\r\n        uint16 intRate,\r\n        uint16 durationInHours,\r\n        uint24 colCoverage,\r\n        Common.Router router\r\n    ) internal {\r\n        if(users.length > 1) revert AddressMustBeArrayOfOneAddress();\r\n        bytes32 ownerHash = _setOwnersHash(users, unit, users[0]);\r\n        if(_getSafe(unit).id == address(0)) {\r\n            if(newSafe == address(0)) revert InvalidSafe();\r\n            require(IERC20(_getToken()).balanceOf(newSafe) >= unit, \"Low Liq\");\r\n            _setSafe(Common.Safe(newSafe, ownerHash), unit); \r\n        }\r\n        if(_getPool(unit, Common.UnitStatus.RECORD).lInt.status == Common.Status.TAKEN) revert PoolIsTaken();\r\n        if(colCoverage < 100) revert CollaterlCoverageTooLow();\r\n        if(durationInHours == 0 || durationInHours > 720) revert DurationExceed720HoursOrIsZero();      \r\n        unchecked {\r\n            _setPool(\r\n                Common.Pool(\r\n                    users[0],\r\n                    address(0),\r\n                    Common.LowInt(quorum, colCoverage, durationInHours * 1 hours, Common.Status.TAKEN, router, Common.Stage.JOIN),\r\n                    Common.BigInt(unit, unit, _getRecordId()),\r\n                    (unit * quorum).computeInterestsBasedOnDuration(intRate, uint24(durationInHours))\r\n                ),\r\n                unit,\r\n                Common.UnitStatus.CURRENT\r\n            );\r\n        }\r\n        _incrementUserCount(unit);\r\n    }\r\n\r\n    function _setOwnersHash(\r\n        address[] memory addrs, \r\n        uint256 unit, \r\n        address admin\r\n    ) internal returns(bytes32 _hash) {\r\n        uint size = addrs.length;\r\n        for(uint i = 0; i < size; i++) {\r\n            address addr = addrs[i];\r\n            if(addr == admin){\r\n                _hash = keccak256(\r\n                    abi.encodePacked(\r\n                        _hash,\r\n                        addr\r\n                    )\r\n                );\r\n            } else { \r\n                _hash = keccak256(\r\n                    abi.encodePacked(\r\n                        _hash,\r\n                        addr,\r\n                        unit\r\n                    )\r\n                );\r\n            }\r\n            _setPoint(addr, 0, 2);\r\n            _addContributor(unit, Common.Contributor(addr == admin, 0, 0, 0, 0, addr, true));\r\n        }\r\n    }\r\n\r\n     function addUserToPool(uint256 unit, address[] memory user) public returns(bool) {\r\n        Common.Pool memory _p = _getPool(unit, Common.UnitStatus.CURRENT);\r\n        Common.Contributor memory _c = _getProfile(user[0], unit);\r\n        _setOwnersHash(user, unit, address(0));\r\n        unchecked {\r\n            _p.bigInt.currentPool += unit;\r\n        }\r\n        if(_p.lInt.stage != Common.Stage.JOIN) revert AddingUserEnded();\r\n        if(user.length > 1) revert UserArrayExceedOne();\r\n        if(IERC20(_getToken()).balanceOf(_getSafe(unit).id) < _p.bigInt.currentPool) revert TokenBalanceInSafeNotTally();\r\n        if(_p.lInt.router == Common.Router.PERMISSIONLESS) require(!_c.isMember, \"User exist\");\r\n        else require(_c.isMember && !_c.sentQuota, \"Already sent quota\");\r\n        _incrementUserCount(unit);\r\n        _addContributor(unit, Common.Contributor(true, 0, 0, 0, 0, user[0], true));\r\n        if(_getUserCount(unit) == _p.lInt.quorum) {\r\n            _p.lInt.stage = Common.Stage.GET;\r\n            _resetUserCount(unit);\r\n            _setTurnTime(_p.admin, unit, Utils._now());\r\n            // _p.beneficiary = _p.admin;\r\n        }\r\n        _setPool(_p, unit, Common.UnitStatus.CURRENT);\r\n\r\n        return true;\r\n    }\r\n\r\n    function setToken(IERC20 newToken) public onlyOwner {\r\n        _replaceToken(newToken);\r\n    }\r\n    \r\n}\r\n"
    },
    "contracts/peripherals/Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nabstract contract Oracle {\r\n\r\n    // Dummy price for development purpose\r\n    function _getDummyPrice() \r\n        internal \r\n        pure \r\n        returns (uint128 _price) \r\n    {\r\n        return 10000000000000000000;\r\n    }\r\n}"
    },
    "contracts/peripherals/Point.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"../apis/Common.sol\";\r\n\r\nabstract contract Point {\r\n\r\n    // Mapping of unit contributors to Point struct\r\n    mapping (address => Common.Point) private points;\r\n\r\n    /**\r\n     * @dev Returns the point\r\n     * @param user : Contributor\r\n    */\r\n    function _getPoint(address user) internal view returns(Common.Point memory point){\r\n        point = points[user];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the point\r\n     * See _getPoint\r\n    */\r\n    function getPoint(address user) public view returns(Common.Point memory){\r\n        return _getPoint(user);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the point information\r\n     * @param user : Unit contribution\r\n     * @param contributor : Point earned as contributor;\r\n     * @param creator : Point earned as a creator\r\n    */\r\n    function _setPoint(address user, uint contributor, uint creator) internal virtual {\r\n        if(contributor > 0) points[user].contributor += contributor;\r\n        if(creator > 0) points[user].creator += creator;\r\n    }\r\n}"
    },
    "contracts/peripherals/Pools.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"../apis/Common.sol\";\r\n\r\nabstract contract Pools {\r\n    uint public pastRecords;\r\n\r\n    // Mapping of unit contribution to past pool\r\n    mapping (uint256 => mapping( Common.UnitStatus => Common.Pool)) private pools; \r\n\r\n    /**\r\n     * @dev Add pool to storage\r\n     * @param pool : A new pool that just ended\r\n     * @param unit : Unit contribution\r\n     */\r\n    function _setPool(Common.Pool memory pool, uint256 unit, Common.UnitStatus status) internal virtual {\r\n        pools[unit][status] = pool;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove pool from storage\r\n     * @param unit : Unit contribution\r\n     */\r\n    function _removePool(uint256 unit) internal virtual {\r\n        delete pools[unit][Common.UnitStatus.CURRENT];\r\n    }\r\n\r\n    /**\r\n     * @dev Get pool from storage\r\n     * @param unit : Unit contribution\r\n     */\r\n    function _getPool(uint256 unit, Common.UnitStatus status) internal view returns(Common.Pool memory) {\r\n        return pools[unit][status];\r\n    }\r\n\r\n    /**\r\n     * @dev Get pool from storage\r\n     * @param unit : Unit contribution\r\n     */\r\n    function isPoolAvailable(uint256 unit) public view returns(bool) {\r\n        return pools[unit][Common.UnitStatus.CURRENT].lInt.status == Common.Status.AVAILABLE;\r\n    }\r\n\r\n    function _getRecordId() internal returns(uint rId) {\r\n        rId = pastRecords;\r\n        pastRecords ++;\r\n    }\r\n}"
    },
    "contracts/peripherals/Safe.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"../apis/Common.sol\";\r\n\r\nabstract contract Safe {\r\n\r\n    // Mapping of unit contribution to Safe struct\r\n    mapping (uint256 => Common.Safe) private safes;\r\n\r\n    /**\r\n     * @dev Returns the safe information\r\n     * @param unit : Unit contribution\r\n    */\r\n    function _getSafe(uint256 unit) public view returns(Common.Safe memory safe){\r\n        safe = safes[unit];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the safe information\r\n     * See _getSafe\r\n    */\r\n    function getSafe(uint256 unit) public view returns(Common.Safe memory){\r\n        return _getSafe(unit);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the safe information\r\n     * @param unit : Unit contribution\r\n     * @param safe : Safe Struct\r\n    */\r\n    function _setSafe(Common.Safe memory safe, uint256 unit) internal virtual {\r\n        safes[unit] = safe;\r\n    }\r\n}"
    },
    "contracts/peripherals/TokenInUse.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IERC20 } from \"../apis/IERC20.sol\";\r\n\r\nabstract contract TokenInUse {\r\n    error InvalidTokenAddress();\r\n    error TokenAddressIsTheSame();\r\n\r\n    IERC20 public token;\r\n\r\n    constructor(IERC20 _token) {\r\n        token = _token;\r\n    }\r\n\r\n    function _replaceToken(IERC20 newToken) internal virtual {\r\n        if(address(newToken) == address(0)) revert InvalidTokenAddress();\r\n        if(newToken == token) revert TokenAddressIsTheSame();\r\n        token = newToken;\r\n    }\r\n\r\n    function _getToken() internal view returns(IERC20 _token) {\r\n        _token = token;\r\n    }\r\n\r\n}"
    },
    "contracts/Simplifi.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"./apis/Common.sol\";\r\nimport { IERC20 } from \"./apis/IERC20.sol\";\r\nimport { Utils } from \"./libraries/Utils.sol\";\r\nimport { CreatePool } from \"./peripherals/CreatePool.sol\";\r\nimport { Oracle } from \"./peripherals/Oracle.sol\";\r\nimport { SafeMath } from \"@thirdweb-dev/contracts/external-deps/openzeppelin/utils/math/SafeMath.sol\";\r\n\r\ncontract Simplifi is CreatePool, Oracle {\r\n    using SafeMath for uint256;\r\n    using Utils for *;\r\n\r\n    error NoDebtFound();\r\n    error SafeBalanceDepleted();\r\n    error GettingFinanceNotReady();\r\n    error InsufficientCollateral();\r\n    error TurnTimeHasNotPassed();\r\n    error PoolBalanceNotTally();\r\n    error PaybackModeNotActivated();\r\n\r\n    constructor(\r\n        address controller, \r\n        address newAgent, \r\n        IERC20 _token\r\n    ) \r\n        CreatePool(controller, newAgent, _token)\r\n    {}\r\n\r\n    function createPermissionlessPool(\r\n        address newSafe, \r\n        address[] memory users, \r\n        uint256 unit,\r\n        uint8 quorum,\r\n        uint16 intRate,\r\n        uint16 durationInHours,\r\n        uint24 colCoverage\r\n    ) public returns(bool) {\r\n        _createPool(\r\n            newSafe, \r\n            users, \r\n            unit,\r\n            quorum,\r\n            intRate,\r\n            durationInHours,\r\n            colCoverage,\r\n            Common.Router.PERMISSIONLESS\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function createPermissionedPool(\r\n        address newSafe, \r\n        address[] memory users, \r\n        uint256 unit,\r\n        uint16 intRate,\r\n        uint16 durationInHours,\r\n        uint24 colCoverage\r\n    ) public returns(bool) {\r\n        _createPool(\r\n            newSafe, \r\n            users, \r\n            unit,\r\n            uint8(users.length),\r\n            intRate,\r\n            durationInHours,\r\n            colCoverage,\r\n            Common.Router.PERMISSIONED\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function getFinance(uint256 unit, address user) public returns(bool) {\r\n        Common.Pool memory _p = _getPool(unit, Common.UnitStatus.CURRENT);\r\n        Common.Contributor memory _c = _getExpected(unit);\r\n        uint256 safeBalance = _getSafe(unit).id.balance;\r\n        if(Utils._now() > _c.turnTime + 1 hours){\r\n            if(user != _c.id) {\r\n                _c = _swapFullProfile(unit, user, _c);\r\n            }\r\n        } else {\r\n            if(user != _c.id) revert TurnTimeHasNotPassed();\r\n        }\r\n        if(_p.lInt.stage != Common.Stage.GET) revert GettingFinanceNotReady();\r\n        if(IERC20(_getToken()).balanceOf(_getSafe(unit).id) < _p.bigInt.currentPool) revert TokenBalanceInSafeNotTally();\r\n        if(_p.bigInt.unit.mul(_p.lInt.quorum) < _p.bigInt.currentPool) revert PoolBalanceNotTally();\r\n        _onlyContributor(_c.id, unit);\r\n        uint fee = _p.bigInt.currentPool.computeFee(uint16(makerRate));\r\n        _c.colBals = _getCollateralQuote(unit);\r\n        if(safeBalance < _c.colBals) revert InsufficientCollateral();\r\n        _c.loan = _p.bigInt.currentPool.sub(fee);\r\n        _p.beneficiary = _c.id;\r\n        _p.bigInt.currentPool = 0;\r\n        _p.lInt.stage = Common.Stage.PAYBACK;\r\n        _addContributor(unit, _c);\r\n        _setPool(_p, unit, Common.UnitStatus.CURRENT);\r\n        _incrementUserCount(unit);\r\n        return true;\r\n    }\r\n\r\n    function payback(uint256 unit, address user) public returns(bool) {\r\n        Common.Pool memory _p = _getPool(unit, Common.UnitStatus.CURRENT);\r\n        Common.Contributor memory _c = _getProfile(user, unit);\r\n        if(_p.lInt.stage != Common.Stage.PAYBACK) revert PaybackModeNotActivated();\r\n        uint debt = _getCurrentDebt(unit, user);\r\n        if(debt == 0) revert NoDebtFound();\r\n        _c.loan = 0;\r\n        bool allGF = _getUserCount(unit) == _p.lInt.quorum;\r\n        if(!allGF){\r\n            _p.bigInt.currentPool = _p.bigInt.unit.mul(_p.lInt.quorum);\r\n            if(IERC20(_getToken()).balanceOf(_getSafe(unit).id) < _p.bigInt.currentPool) revert SafeBalanceDepleted();\r\n            _p.lInt.stage = Common.Stage.GET;\r\n            _setTurnTime(address(0), unit, Utils._now());\r\n            _setPool(_p, unit, Common.UnitStatus.CURRENT);\r\n        } else {\r\n            _p.lInt.stage = Common.Stage.ENDED;\r\n            _setPool(_p, unit, Common.UnitStatus.RECORD);\r\n            _removePool(unit);\r\n        }\r\n        _addContributor(unit, _c);\r\n        return true;\r\n    }\r\n\r\n    /**@dev Return accrued debt for user up to this moment.\r\n     * @param unit : Contribution amount.\r\n     * @param user : Contributor.\r\n     * @notice This is the total accrued debt between the date user was paid and now.\r\n     */\r\n    function _getCurrentDebt(uint256 unit, address user) \r\n        internal \r\n        view returns(uint debt) \r\n    {\r\n        uint intPerSec = _getPool(unit, Common.UnitStatus.CURRENT).interest.intPerSec;\r\n        Common.Contributor memory _c = _getProfile(user, unit);\r\n        debt = _c.loan.add(intPerSec.mul(uint(Utils._now()).sub(_c.turnTime)));\r\n    } \r\n\r\n    /**@dev Return accrued debt for user up to this moment.\r\n     * @param unit : Contribution amount.\r\n     * @param user : Contributor.\r\n     * @notice This is the total accrued debt between the date user was paid and now.\r\n     */\r\n    function getCurrentDebt(uint256 unit, address user) \r\n        public \r\n        view returns(uint debt) \r\n    {\r\n        return _getCurrentDebt(unit, user);\r\n    } \r\n    \r\n    function _getCollateralQuote(uint256 unit) internal view returns(uint quote){\r\n        Common.Pool memory _p = _getPool(unit, Common.UnitStatus.CURRENT);\r\n        quote = Common.Price(_getDummyPrice(), 18).computeCollateral(uint24(_p.lInt.colCoverage), _p.bigInt.currentPool);\r\n    }\r\n\r\n    function getCollateralQuote(uint256 unit) public view returns(uint quote){\r\n       return _getCollateralQuote(unit);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if slot is available in the pool\r\n     * @param unit : Unit contribution\r\n     */\r\n    function isPoolVacant(uint256 unit) public view returns(bool) {\r\n        return _getUserCount(unit) < _getPool(unit, Common.UnitStatus.CURRENT).lInt.quorum;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}